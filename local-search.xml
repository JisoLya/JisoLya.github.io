<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式-1 装饰器模式</title>
    <link href="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>简单的来说，就是为某一个类&#x2F;对象增加一些额外的功能，类似于Spring的AOP，执行方法增强。</p><h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><p>目标：学习装饰器模式<br>课题：<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/request.png"><br>实现这样一个功能，在接收到post请求之后，为map添加一个<code>timestamp</code>字段，值为当前的时间戳(不依赖Spring的AOP)。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>为了实现这个装饰器，我们首先需要知道这里的map是怎么获取到的，这里直接打一个断点进入堆栈，对接口发送图中的请求。</p><p>在接口收到请求之后，我们很容易就可以定位到这个方法，进入这个方法中，发现有<code>getMethodArgumentValues</code>这个方法的调用。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug0.png"></p><p>点进这个方法，看到这个方法中关于<code>args</code>的赋值逻辑:交给<code>resolver.resolveArgument()</code>进行处理，那么这个真正的逻辑就藏在<code>resolver</code>中。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug1.png"><br>接着去看<code>resolvers</code>都是什么？ (<code>HandlerMethodArgumentResolverComposite</code>)<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug2.png"><br>同时如果不加配置的情况下，<code>resolvers</code>的size应该是27个(这里就不截图了)。因此可以确定，我们如果想实现目标，需要添加一个自定义的resolver或者是对某一个resolver进行增强，也就符合装饰器模式的定义，也就需要再看看Spring是什么时候添加这些resolver的，点进去这个<code>HandlerMethodArgumentResolverComposite</code>给这几个<code>addResolver()</code>打上断点，再看看调用堆栈。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug3.png"><br>很容易定位到下边这些个箭头的方法~，这个<code>getDefaultArgumentResolvers</code>是一坨巨大的石山(一个个new出来然后再add)。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug4.png"></p><p>接着再回来，这里的<code>HandlerMethodArgumentResolverComposite</code>也是一种装饰器模式的实现，即它本身是一个<code>...resolver</code>，里边又塞了一个<code>resolver</code>的list，在实际执行resolve方法的时候，他先获取支持当前param的resolver再丢给对应的resolver进行处理。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug5.png"><br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug6.png"></p><p>那么带有<code>@RequestBody</code>注解的param是通过哪一个<code>resolver</code>进行处理的，答案是<code>RequestResponseBodyMethodProcessor</code>，这时就比较简单了，我们需要查看一下这个resolver是怎么进行supportArgument的,再自定义一个resolver进行增强。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug7.png"></p><p>那么接下来我们需要做两件事情：</p><ol><li>检查一下怎么supportArgument</li><li>依据supportArgument的结果，自行魔改一下。</li><li>看一下怎么把我们装饰之后的东西放到先前的resolvers中</li></ol><p>可以看到，他是直接检查是否有<code>@RequestBody</code>注解，来判断是否<code>supportArgument</code>，那么controller中的map就是在这个类下的<code>resolveArgument()</code>中创建的，到这，我们就大体可以实现目标了。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug8.png"><br>简单写一下我们的装饰器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liuyan.wrapperspringboot.decorater;<br><br><span class="hljs-keyword">import</span> com.liuyan.wrapperspringboot.annotation.TimeStampRequestBody;<br><span class="hljs-keyword">import</span> org.springframework.core.MethodParameter;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.support.WebDataBinderFactory;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.NativeWebRequest;<br><span class="hljs-keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;<br><span class="hljs-keyword">import</span> org.springframework.web.method.support.ModelAndViewContainer;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的resolver，实际上是对RequestResponseBodyMethodProcessor进行装饰</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeStampMethodProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerMethodArgumentResolver</span> &#123;<br><br>HandlerMethodArgumentResolver processor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断一下含有我们自定义注解的参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parameter</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> &#123;<br><span class="hljs-keyword">return</span> parameter.hasParameterAnnotation(TimeStampRequestBody.class);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//直接交给我们装饰的对象进行处理</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> processor.resolveArgument(parameter, mavContainer, webRequest, binderFactory);<br><span class="hljs-keyword">if</span> (!(result <span class="hljs-keyword">instanceof</span> Map)) &#123;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>((Map) result).put(<span class="hljs-string">&quot;timeStamp&quot;</span>, System.currentTimeMillis());<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么目标1，2都已经实现了，接着我们要看看怎么把我们的decorater放到resolvers中。还记得我们我们之前说的一段石山代码吗，那里就是初始化这里<code>resolvers</code>代码的敌方，不过我们需要的是添加到自定义的resolver,截一部分图看看吧~。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug9.png"><br>点进去看看我们要怎么添加，就可以完成目标咯，但是图中的这个类只有他的set方法，那么还需要看看这个set是什么时候被调用的，给set方法打一下断点.<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug10.png"><br>调用他的类名字叫<code>WebMvcConfigurationSupport</code>，大概率是配置类，再根据调用点点点。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug11.png"><br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug12.png"><br>这里就是添加<code>argumentResolver</code>的地方，还是一个经典的懒加载，那么再进入一下这里的方法调用，发现这是一个接口，那么找找实现类，其中只有一个<code>DelegatingWebMvcConfiguration</code>，仔细观察一下这个类的代码，又是一个经典的装饰器实现，那我们势必要再看看他装饰的类(<code>WebMvcConfigurerComposite</code>)中<code>addArgumentResolver</code>的实现了，可以找到一个<code>addWebMvcConfigurers</code>的方法被调用，就需要看看<code>DelegatingWebMvcConfiguration</code>是怎么调用这个方法的了。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug13.png"><br>这里就可以看到了，他收集了所有实现了<code>WebMvcConfigurer</code>接口的类，加入到我们期望的list当中，写一个configurer类，实现<code>WebMvcConfigurer</code>接口，在<code>addArgumentResolvers</code>方法中添加我们的decorater。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomWebConfigurer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加入我们自定义的解析器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resolvers</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> &#123;<br>resolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeStampMethodProcessor</span>());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新启动一下验证有没有加入。<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/debug14.png"><br>可以看到是已经加入了，但是现在还有一个问题，我们的自定义类中的processor是没有赋值了，那么该怎么获取到这个东西呢，因为我们原本包装的这个对象是通过new关键字直接加入到对应list当中的，我们需要拿到持有这个list的容器，通过遍历的方式来初始化我们的processor。<code>RequestMappingHandlerAdapter</code>这个类已经交给Spring容器进行管理了，那么事情就很简单。</p><p>不过我们没有把自己的类定义成Bean，所以还用不了<code>@Autowired</code>，可以直接通过ApplicationContext来获取，贴一小部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setupProcessor</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (processor != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">RequestMappingHandlerAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationContext.getBean(RequestMappingHandlerAdapter.class);<br><span class="hljs-keyword">for</span> (HandlerMethodArgumentResolver resolver : adapter.getArgumentResolvers()) &#123;<br><span class="hljs-keyword">if</span> (resolver <span class="hljs-keyword">instanceof</span> RequestResponseBodyMethodProcessor) &#123;<br>processor = resolver;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们的目标就完成了，结果如下图<br><img src="/2025/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/res.png"></p><p>代码链接: <a href="https://github.com/JisoLya/DesignPattern/tree/master/WrapperSpringBoot">https://github.com/JisoLya/DesignPattern/tree/master/WrapperSpringBoot</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HugeGraph重构-store-gRPC模块解析</title>
    <link href="/2025/07/13/HugeGraph%E9%87%8D%E6%9E%84-store-gRPC%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/07/13/HugeGraph%E9%87%8D%E6%9E%84-store-gRPC%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="hg-store-rpc模块"><a href="#hg-store-rpc模块" class="headerlink" title="hg-store-rpc模块"></a>hg-store-rpc模块</h1><p>本模块采用了gRPC作为通信协议，为了更好的了解rpc的过程，我们需要先了解一下什么是gRPC。</p><h2 id="什么是gRPC"><a href="#什么是gRPC" class="headerlink" title="什么是gRPC"></a>什么是gRPC</h2><p>RPC，全称<code>Remote Procedure Call</code>，中文译为远程过程调用。通俗地讲，使用RPC进行通信，调用远程函数就像调用本地函数一样，RPC底层会做好数据的序列化与传输，从而能使我们更轻松地创建分布式应用和服务。</p><p>而gRPC是RPC的一种，是由Google免费开源的一个RPC通信协议，我们只需要好API的Request与Response，其余的事情由gRPC帮我们实现。<br><img src="/2025/07/13/HugeGraph%E9%87%8D%E6%9E%84-store-gRPC%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/gRpc.png" alt="gRPC"><br>默认的情况下，gRPC使用Protocol Buffers作为接口定义语言(IDL)，本质上是一个序列化结构化数据的过程，比如Java中的<code>class</code>或者是cpp中的<code>struct</code>&#x2F;<code>class</code>的过程，在使用的过程中你也可以使用JSON作为序列化，可以在不同的服务之间进行通信。</p><p>简单的来说，gRpc就是一套由Google实现的服务通信框架更多的详细信息可以参考：<br><a href="https://grpc.org.cn/docs/what-is-grpc/introduction/">https://grpc.org.cn/docs/what-is-grpc/introduction/</a></p><h2 id="gRPC-In-HugeGraph"><a href="#gRPC-In-HugeGraph" class="headerlink" title="gRPC In HugeGraph"></a>gRPC In HugeGraph</h2><p>作为一个存算分离架构的图数据库，不同的模块需要部署在不同的设备上，那么此时服务间的调用就需要用到RPC，HugeGraph采用了gRPC作为通信框架。</p><p>这里主要说明一下<code>store</code>模块的gRPC定义(定义在<code>hugegraph-store/huge-store-grpc</code>这个模块下)<br>下边是各个<code>.proto</code>文件的含义</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hg<span class="hljs-punctuation">-</span>store<span class="hljs-punctuation">-</span>grpc/src/main/proto/<br>         <span class="hljs-string">|</span><br>         <span class="hljs-string">|- graphpb.proto (定义 GraphStore 服务，用于流式扫描图分区中的顶点和边)</span><br>         <span class="hljs-string">|</span><br>         <span class="hljs-string">|- healthy.proto (定义 Healthy 服务，用于健康检查)</span><br>         <span class="hljs-string">|</span><br>         <span class="hljs-string">|- query.proto (定义 QueryService 服务，用于复杂的聚合下推查询)</span><br>         <span class="hljs-string">|</span><br>         <span class="hljs-string">|- store_common.proto (定义通用的数据结构和枚举)</span><br>         <span class="hljs-string">|</span><br>         <span class="hljs-string">|- store_session.proto (定义 HgStoreSession 服务，提供核心 CRUD 和事务管理)</span><br>         <span class="hljs-string">|</span><br>         <span class="hljs-string">|- store_state.proto (定义 HgStoreState 服务，用于监控节点状态)</span><br>         <span class="hljs-string">|</span><br>         <span class="hljs-string">|- store_stream_meta.proto (定义流式扫描的元数据和复杂控制接口)</span><br></code></pre></td></tr></table></figure><p>下面主要关注一下这几个<code>.proto</code>文件的内容</p><ol><li><strong><code>graphpb.proto</code></strong><br>  文件中首先定义了一个rpc服务</li></ol>  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">GraphStore</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> ScanPartition(stream ScanPartitionRequest) <span class="hljs-keyword">returns</span> (stream ScanResponse)</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  这个rpc的请求与响应都以流式传输<br>  请求消息分为两种，分别是初始的扫描请求scan_request，或者是某一个请求的响应。<br>  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">ScanPartitionRequest</span>&#123;<br>  <span class="hljs-comment">//...</span><br>  RequestHeader header = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">oneof</span> request &#123;<br>    Request scan_request = <span class="hljs-number">2</span>;<br>    Reply reply_request = <span class="hljs-number">4</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  接下来是<code>Request</code>的定义，依次指明了扫描的类型，分区信息以及用于过滤一些信息等。<br>  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Request</span>&#123;<br>  ScanType scan_type = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> graph_name = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">uint32</span> partition_id = <span class="hljs-number">3</span>;<br>  <span class="hljs-type">uint32</span> start_code = <span class="hljs-number">4</span>;<br>  <span class="hljs-type">uint32</span> end_code = <span class="hljs-number">5</span>;<br>  <span class="hljs-comment">// Filter conditions</span><br>  <span class="hljs-type">string</span> condition = <span class="hljs-number">6</span>;<br>  <span class="hljs-type">string</span> table = <span class="hljs-number">7</span>;<br>  <span class="hljs-type">int64</span> limit = <span class="hljs-number">8</span>;<br>  <span class="hljs-type">int32</span> boundary = <span class="hljs-number">9</span>;<br>  <span class="hljs-type">bytes</span> position = <span class="hljs-number">10</span>;<br>  <span class="hljs-comment">// Return condition</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">int64</span> properties = <span class="hljs-number">11</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>  响应消息<code>ScanResponse</code>，<em>repeated</em> 关键字表示每次响应是一个列表，而不是一个个的vertex或Edge。<br>  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">ScanResponse</span>&#123;<br>  ResponseHeader header = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// Message Sequence Number</span><br>  <span class="hljs-type">int32</span>     seq_no = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">repeated</span>  Vertex vertex = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">repeated</span>  Edge edge = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>2. <strong><code>healthy.proto</code></strong><br>  文件中定义了一个简单的<code>Healthy</code>的RPC服务，用于健康检查。<br>  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">Healthy</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> IsOk(google.protobuf.Empty) <span class="hljs-keyword">returns</span> (StringReply) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">StringReply</span> &#123;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>3. <strong><code>query.proto</code></strong> –new<br>  这一个是在3.7版本中新增的proto文件，也是store-grpc这一模块的关键更新，这个proto中定义了支持查询下推功能的RPC消息。<br>  首先是服务的定义<br>  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">QueryService</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> query(stream QueryRequest) <span class="hljs-keyword">returns</span> (stream QueryResponse) </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> query0(QueryRequest) <span class="hljs-keyword">returns</span> (QueryResponse) </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> count(QueryRequest) <span class="hljs-keyword">returns</span> (QueryResponse) </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  分别定义了三个RPC服务，一个是以流的形式来接受请求与响应，一个简单的一元 RPC（即一个请求对应一个响应）。它适用于那些预计能快速返回结果的、较小的查询。最后则是一个计数请求，可以看作是对COUNT请求的优化。</p><p>  query中最关键的部分则是<code>stream QueryRequest</code>这个查询请求。<br>  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">QueryRequest</span>&#123;<br>  <span class="hljs-type">string</span> queryId = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> graph = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">string</span> table = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-keyword">repeated</span> AggregateFunc functions = <span class="hljs-number">4</span>;<br>  <span class="hljs-comment">// 属性剪裁，如果为空，则返回所有的属性, aggregation 作为单独字段，不包含此列</span><br>  <span class="hljs-comment">// 如果有group by，应该是group by的子集</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">bytes</span> property = <span class="hljs-number">5</span>;<br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">bytes</span> group_by = <span class="hljs-number">6</span>; <span class="hljs-comment">// group by的字段</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">uint32</span> having = <span class="hljs-number">7</span>;   <span class="hljs-comment">// having 的过滤</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">bytes</span> order_by = <span class="hljs-number">8</span>; <span class="hljs-comment">// order by 字段</span><br>  <span class="hljs-type">bool</span> sort_order = <span class="hljs-number">9</span>; <span class="hljs-comment">// asc or desc</span><br>  <span class="hljs-type">bool</span> null_property = <span class="hljs-number">10</span>; <span class="hljs-comment">// 不使用property，仅仅返回key</span><br><br>  ScanType scan_type = <span class="hljs-number">11</span>; <span class="hljs-comment">// 表扫描类型, 如果有索引，此项忽略</span><br><br>  <span class="hljs-keyword">repeated</span> ScanTypeParam scan_type_param = <span class="hljs-number">12</span>; <span class="hljs-comment">// id, prefix 只用到start</span><br><br>  DeDupOption dedup_option = <span class="hljs-number">13</span>;  <span class="hljs-comment">// 是否需要key消重</span><br><br>  <span class="hljs-type">bytes</span> condition = <span class="hljs-number">21</span>; <span class="hljs-comment">// condition</span><br>  <span class="hljs-type">bytes</span> position = <span class="hljs-number">24</span>;            <span class="hljs-comment">// 返回offset ~ offset + limit</span><br>  <span class="hljs-type">uint32</span> limit = <span class="hljs-number">23</span>;             <span class="hljs-comment">// page</span><br>  <span class="hljs-type">uint32</span> offset = <span class="hljs-number">25</span>;           <span class="hljs-comment">// offset</span><br><br>  <span class="hljs-type">double</span> sample_factor = <span class="hljs-number">31</span>; <span class="hljs-comment">// 抽样频率，应该小于等于1</span><br><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">bytes</span> olap_property = <span class="hljs-number">32</span>; <span class="hljs-comment">// 读取的olap 属性</span><br><br>  <span class="hljs-comment">// 使用的索引, 第一层为or关系，第二层为 and关系</span><br>  <span class="hljs-comment">// indexes ((index,index) or (index, index))</span><br>  <span class="hljs-keyword">repeated</span> Index indexes = <span class="hljs-number">41</span>;<br><br>  <span class="hljs-type">bool</span> load_property_from_index = <span class="hljs-number">42</span>;<br>  <span class="hljs-type">bool</span> check_ttl = <span class="hljs-number">43</span>;<br>  <span class="hljs-comment">// 按照element的 label id group by</span><br>  <span class="hljs-type">bool</span> group_by_schema_label = <span class="hljs-number">44</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>  消息中比较重要的是<code>AggregateFunc</code>指明了聚合操作的函数类型，常见的如<code>COUNT</code>、<code>SUM</code>、<code>AVG</code>等；<code>property</code>告诉服务端只需要返回哪些属性（字段），而不是返回整个顶点或边的所有数据，以此减少网络传输量；而<code>group_by</code>、<code>having</code>、<code>order by</code>则类似于Mysql中的类似操作；<code>condition</code>则是指明了过滤条件类比Mysql中的where子句；</p><p>  最后则是<code>QueryResponse</code><br>  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">QueryResponse</span> &#123;<br>  <span class="hljs-type">string</span> query_id = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">bool</span> is_ok = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">bool</span> is_finished = <span class="hljs-number">3</span>;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">repeated</span> Kv data = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>  关键字段为<code>is_finished</code>用来标记流式响应是否结束，<code>Kv data</code>则是以K-V的形式返回数据，需要注意的是，如果是聚合操作，那么返回的则会是聚合后的结果。</p><ol start="4"><li><strong><code>store_common.proto</code></strong> –updated<br>  这个proto文件主要定义了HugeGraph的gRPC中通用的一些数据结构与枚举类型</li></ol><ul><li>Key: 只包含一个 key 的结构。</li><li>Tkv: “Tabled Key-Value” 的缩写，即带所属表信息的键值对 (table, key, value)。</li><li>Tk: “Tabled Key” 的缩写，即带所属表信息的键 (table, key)。</li><li>Tp: “Tabled Prefix” 的缩写，即带所属表信息的前缀 (table, prefix)，用于前缀扫描。</li><li>Tse: “Tabled Start-End” 的缩写，即带所属表信息的范围 (table, start key, end key)，用于范围扫描。</li></ul><p>  在新版本中新添加了一个结构<code>TTLCleanRequest</code>，这个Request用于清理过期的数据，因而需要定位到数据所在的图&#x2F;分片&#x2F;表等信息，以及过期数据的IDs。<br>  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">TTLCleanRequest</span> &#123;<br>  <span class="hljs-type">string</span> graph = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> partitionId = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">string</span> table = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">bytes</span> ids = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>  其余的一些枚举则都可以见名知意，这里就不做解释了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HNSW论文笔记</title>
    <link href="/2025/05/11/HNSW%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/05/11/HNSW%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HNSW-层次化可导航的小世界"><a href="#HNSW-层次化可导航的小世界" class="headerlink" title="HNSW 层次化可导航的小世界"></a>HNSW 层次化可导航的小世界</h1><p>背景就不一一解释了， 主要是为了解决相似性查找的问题。</p><h3 id="相关概念介绍"><a href="#相关概念介绍" class="headerlink" title="相关概念介绍"></a>相关概念介绍</h3><h4 id="1-Proximity-Graph"><a href="#1-Proximity-Graph" class="headerlink" title="1. Proximity Graph"></a>1. Proximity Graph</h4><p><em>Proximity Graph</em> 的主要思想是，随机选取一个开始节点， 从这个节点开始搜索它的邻居，找到邻居中和目标节点距离最近的一个， 再以这个邻居开始进行下一轮迭代。</p><p>思路很简单的同时，存在着非常多的问题，最为关键的就是搜索复杂度无法确定，孤岛效应难以解决，以及构建图的开销太高，复杂度达到了指数级别。</p><h4 id="2-可导航的小世界模型"><a href="#2-可导航的小世界模型" class="headerlink" title="2. 可导航的小世界模型"></a>2. 可导航的小世界模型</h4><p><em>Navigable small world models</em> 的主要思想是：我们把库中的节点随机插入图中，每次插入节点的时候都找图中和被插入节点最近的M个每个节点连边，这样保证了图的连通性。</p><blockquote><p>文章反复提到的对数多项式复杂度实际上是:<br>$$a_{k}log^{k}(n)+…+a_1log(n)+a_0$$</p></blockquote><h3 id="HNSW算法简单概述"><a href="#HNSW算法简单概述" class="headerlink" title="HNSW算法简单概述"></a>HNSW算法简单概述</h3><p>NSW中单个贪心搜索的多对数复杂性的原因在于，总的距离计算次数大致与贪心算法跳转的平均次数与贪心路径上节点的平均度数的乘积成正比。</p><p>HNSW的主要思想是根据节点之间连接的长度尺度将图分为不同的层，然后再多层图中进行搜索。<br><img src="/.com//layersearch.png" alt="图1. layersearch.png"></p><!-- 本地预览的时候用下边这个引用方式，否则博客上显示不出来 --><!-- ![layersearch.png](./HNSW论文笔记/layersearch.png) --><p>自图1中的最上层开始，这一层有最长的连接(“zoom in”阶段)，算法会利用贪婪的思想，不断从当前层搜索，直至当前这一层中与目标距离最接近的；接着，算法会进入下一层，紧接着重复上面的步骤。不难想到，底层的子图中会包含有上层的节点，因为在跳转的过程中，下一层的搜索是从上一层的结束节点开始的。</p><p>最近忙着landing，今天正好周末了，更新一下笔记吧~  2025.5.24</p><p>论文中提到，层与层之间的连接可以被设置为某一个常量。一种构造这种层次结构的措施是：对于图中的每一个节点，我们可以分配一个整型数字l，表示这个节点所在的层数。同时，如果我们设置一种有关l的指数衰减的概率，那么每一层的节点数大致就是以 <code>2 -&gt; 4 -&gt; 8</code>指数的形式来增长的，保证了算法的搜索效率(类似与跳表)。</p><p>与NSW不同的是，在节点插入之前，节点不需要被打乱，HNSW的随机性由随机的layer来实现。在节点插入的时候，采用了一种启发式的方法，考虑到所有节点之间的距离而不是仅仅选择距离最近的一个节点。<br><img src="/.com//insertion.png" alt="图2. 插入节点的表示"><br>在图2中，如果插入的节点在Cluster 1的范围中，如果选取距离最近的一个节点来建立连接，那么会破环整个图结构的连接性，文章中说到的启发式的方法将这种情况也考虑到，这样整个图仍旧是一个<em>Delaunay graph</em>，同时防止插入节点与$e_2$的距离要小于Cluster 1中节点距离的情况。</p><blockquote><p><strong>Algorithm 1</strong><br>图的构建过程是由连续的将候选元素插入到图中实现的：<br>INSERT(hnsw, q, M, Mmax, efConstruction, mL)<br>输入参数说明：</p><ol><li>层次图 $hnsw$</li><li>新插入的元素$q$</li><li>已有的连接数$M$</li><li>每层每个元素的最大连接数$M_{max}$</li><li>动态候选元素的列表大小 $efConstruction$</li><li>用于层级生成的归一化因子$m_L$</li></ol><p>输出：更新后的$hnsw$<br>算法流程：<br>1  $W \leftarrow Ø$ &#x2F;&#x2F; 当前发现最邻近的节点列表<br>2  $ep \leftarrow hnsw 的入口节点$<br>3  $L \leftarrow 入口节点的层级$ &#x2F;&#x2F; $hnsw$的最高层<br>4  $l \leftarrow [-ln(uniform(0..1))·m_l]$ &#x2F;&#x2F; 新节点的层级<br>5  $for \space l_c  \leftarrow L … l+1:$<br>6  $\quad W \leftarrow SEARCHLAYER(q, ep, ef&#x3D;1, l_c)$ &#x2F;&#x2F; searchlayer是Algorithm 2<br>7  $\quad ep \leftarrow$ 从$W$中获取距离$q$最近的节点<br>8  $end \space for$<br>9  $for\space l_c \leftarrow min(L,l)… 0:$<br>10 $\quad W \leftarrow SEARCHLAYER(q, ep, efConstruction, l_c)$<br>11 $\quad neighbors \leftarrow SELECTNEIGHBORS(q, W, M, l_c)$&#x2F;&#x2F; Algorithm 3 或Algorithm 4<br>12 $\quad$ 添加从q到neighbors的双向连接<br>13 $\quad for \space each\space e \in neighbors:$<br>14 $\quad \quad eConn\leftarrow neighbourhood(e) \space (l_c层)$<br>15 $\quad \quad if \space |eConn| &gt; M_max:$<br>16 $\quad \quad \quad  eNewConn \leftarrow SELECTNEIGHBORS(e, eConn,  M_max, l_c)$<br>17 $\quad \quad \quad 将l_c这一层的neighbor(e)设置为 eNewConn$<br>18 $\quad \quad end \space if$<br>19 $\quad \quad ep \leftarrow W$<br>20 $\quad end \space for$<br>21 $if \space l &gt; L$<br>22 $\quad 将hnsw的入口设置为q$<br>23 $end\space if$</p></blockquote><p>ps: 2025&#x2F;9&#x2F;4<br>后续也没有再看这个东西了，咕咕咕…</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
