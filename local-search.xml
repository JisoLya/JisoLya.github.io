<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HNSW论文笔记</title>
    <link href="/2025/05/11/HNSW%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/05/11/HNSW%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HNSW-层次化可导航的小世界"><a href="#HNSW-层次化可导航的小世界" class="headerlink" title="HNSW 层次化可导航的小世界"></a>HNSW 层次化可导航的小世界</h1><p>背景就不一一解释了， 主要是为了解决相似性查找的问题。</p><h3 id="相关概念介绍"><a href="#相关概念介绍" class="headerlink" title="相关概念介绍"></a>相关概念介绍</h3><h4 id="1-Proximity-Graph"><a href="#1-Proximity-Graph" class="headerlink" title="1. Proximity Graph"></a>1. Proximity Graph</h4><p><em>Proximity Graph</em> 的主要思想是，随机选取一个开始节点， 从这个节点开始搜索它的邻居，找到邻居中和目标节点距离最近的一个， 再以这个邻居开始进行下一轮迭代。</p><p>思路很简单的同时，存在着非常多的问题，最为关键的就是搜索复杂度无法确定，孤岛效应难以解决，以及构建图的开销太高，复杂度达到了指数级别。</p><h4 id="2-可导航的小世界模型"><a href="#2-可导航的小世界模型" class="headerlink" title="2. 可导航的小世界模型"></a>2. 可导航的小世界模型</h4><p><em>Navigable small world models</em> 的主要思想是：我们把库中的节点随机插入图中，每次插入节点的时候都找图中和被插入节点最近的M个每个节点连边，这样保证了图的连通性。</p><blockquote><p>文章反复提到的对数多项式复杂度实际上是:<br>$$a_{k}log^{k}(n)+…+a_1log(n)+a_0$$</p></blockquote><h3 id="HNSW算法"><a href="#HNSW算法" class="headerlink" title="HNSW算法"></a>HNSW算法</h3><p>NSW中单个贪心搜索的多对数复杂性的原因在于，总的距离计算次数大致与贪心算法跳转的平均次数与贪心路径上节点的平均度数的乘积成正比。</p><p>HNSW的主要思想是根据节点之间连接的长度尺度将图分为不同的层，然后再多层图中进行搜索。<br><img src="/./HNSW%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/layersearch.png#pic_center"><br>自图中的红色节点开始，利用贪心算法搜索和它距离最近的一个节点，然后逐层搜索直至搜索到最下层。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
